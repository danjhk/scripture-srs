<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Scripture SRS</title>
    <!-- Tailwind (for the classes you already use) -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React + ReactDOM + Babel (lets us run your JSX in-browser) -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Supabase UMD -->
    <script src="https://unpkg.com/@supabase/supabase-js@2.45.4/dist/umd/supabase.js"></script>

    <!-- Put your Supabase keys here later (Phase 2). For now, leave empty. -->
    <script>
      window.SUPABASE_URL = "https://wfqbfapvwrulfzblskws.supabase.co";   // e.g., "https://xxxx.supabase.co"
      window.SUPABASE_ANON = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6IndmcWJmYXB2d3J1bGZ6Ymxza3dzIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTg0NTkxMTUsImV4cCI6MjA3NDAzNTExNX0.lzLU2X3sY6seixhUyJqQu4jaw84CmtQnsLl328fPB9o";  // e.g., "eyJhbGciOiJIUzI1NiIsInR5cCI6Ikp..."
    </script>

    <style>
      body { background: #f8fafc; }
      /* Mobile guard: never allow horizontal scrolling */
      html, body { max-width: 100%; overflow-x: hidden; }
    </style>
  </head>
  <body>
    <div id="root"></div>

    <!-- Your app code -->
    <script type="text/babel" data-type="module" src="./app.jsx"></script>

    <script>
    (function initAuthBar() {
      // Render the bar immediately so something is visible
      const bar = document.createElement('div');
      bar.style.position='fixed'; bar.style.top='8px'; bar.style.right='8px'; bar.style.zIndex='100000';
      bar.innerHTML = `
        <button id="srs-signin" class="px-3 py-2 rounded-xl bg-indigo-600 text-white">Sign in</button>
        <button id="srs-signout" class="px-3 py-2 rounded-xl bg-gray-200" style="display:none">Sign out</button>
      `;
      document.body.appendChild(bar);

      const signinBtn  = document.getElementById('srs-signin');
      const signoutBtn = document.getElementById('srs-signout');

      // Hide both buttons until we know the auth state
      signinBtn.style.display = 'none';
      signoutBtn.style.display = 'none';

      // Disable until Supabase is loaded
      signinBtn.disabled = true;
      signinBtn.textContent = 'Loading...';

      function ready(cb) {
        if (window.supabase) return cb();
        const s = document.querySelector('script[src*="supabase-js"]');
        if (s) s.addEventListener('load', () => cb(), { once: true });
        const t = setInterval(() => {
          if (window.supabase) { clearInterval(t); cb(); }
        }, 50);
      }

      // --- NEW: make start async and only clean hash AFTER session is set
      async function start() {
        const client = window.supabase.createClient(
          window.SUPABASE_URL,
          window.SUPABASE_ANON,
          { auth: { persistSession: true, detectSessionInUrl: true }, realtime: { enabled: false } }
        );
        window.supabaseClient = client;
        let didInitialPull = false;
        // --- Sync status (global) ---
        window.srsSync = { pushing:false, pulling:false, lastPullAt:null, lastPushAt:null };
        const emitSync = () => window.dispatchEvent(new CustomEvent('srs-sync'));

        window._pushing = false;        // guard: we're currently pushing
        window._syncFromCloud = false;  // guard: we're applying pull → don't auto-push

        // Track which entities really changed since last push
        window._dirty = { cards:false, settings:false, history:false, capLog:false };
        window.markDirty = (...keys) => {
          for (const k of keys) if (k in window._dirty) window._dirty[k] = true;
          // schedule a batched push soon (but NOT on every keystroke thanks to debounce)
          if (!window._syncFromCloud && typeof window.schedulePush === 'function') {
            window.schedulePush();
          }
        };

        const cleanupHash = () => {
          if (location.hash && location.hash.includes('access_token')) {
            history.replaceState({}, '', location.pathname + location.search);
          }
        };

        async function refreshButtons() {
          const { data } = await client.auth.getUser();
          const signedIn = !!data.user;
          signinBtn.style.display  = signedIn ? 'none' : '';
          signoutBtn.style.display = signedIn ? '' : 'none';

          if (signedIn && !didInitialPull) {
            didInitialPull = true;
            const uid = data.user.id;
            await pullAll();
            await startRealtime(uid);
          }
          if (!signedIn) { await stopRealtime(); }
        }

        signinBtn.disabled = false;
        signinBtn.textContent = 'Sign in';

        signinBtn.onclick = async () => {
          const email = prompt("Enter your email for a sign-in link:");
          if (!email) return;
          const redirectTo = `${location.origin}${location.pathname}`; // exact page (no hash/query)
          const { error } = await client.auth.signInWithOtp({
            email,
            options: { emailRedirectTo: redirectTo }
          });
          if (error) alert(error.message);
          else alert("Check your email and click the sign-in link.");
        };

        signoutBtn.onclick = async () => {
          await client.auth.signOut();
          await stopRealtime();
          refreshButtons();
        };

        // --- NEW: let Supabase parse URL first, then tidy URL if signed in
        const { data: { session } } = await client.auth.getSession();
        if (session?.user) cleanupHash();
        await refreshButtons();

        client.auth.onAuthStateChange((event, session) => {
          console.log('Auth event:', event, session?.user?.email || null);
          if (event === 'SIGNED_IN' && session?.user) cleanupHash();
          refreshButtons(); // safe; won't loop-pull now
        });

        // ---- your existing helpers (unchanged) ----
        function getState() {
          try {
            const s = JSON.parse(localStorage.getItem("scripture_srs_v1")) || { cards:[], settings:{} };
            if (!s.capLog) s.capLog = {};  // ← NEW: ensure present
            return s;
          } catch {
            return { cards:[], settings:{}, capLog:{} };
          }
        }
        function setCardsLocal(cards) {
          const st = getState(); st.cards = cards;
          localStorage.setItem("scripture_srs_v1", JSON.stringify(st));
          // Let the app know cloud data landed:
          window.dispatchEvent(new CustomEvent('srs:pulled', { detail: { entity: 'cards', at: Date.now() }}));
        }
        function setSettingsLocal(settings) {
          const st = getState(); st.settings = settings;
          localStorage.setItem("scripture_srs_v1", JSON.stringify(st));
          window.dispatchEvent(new CustomEvent('srs:pulled', { detail: { entity: 'settings', at: Date.now() }}));
        }

        function setHistoryLocal(history) {
          const st = getState(); st.history = history;
          localStorage.setItem("scripture_srs_v1", JSON.stringify(st));
          window.dispatchEvent(new CustomEvent('srs:pulled', { detail: { entity: 'history', at: Date.now() }}));
        }

        function setCapLogLocal(capLog) {
          const st = getState(); st.capLog = capLog;
          localStorage.setItem("scripture_srs_v1", JSON.stringify(st));
          window.dispatchEvent(new CustomEvent('srs:pulled', { detail: { entity: 'capLog', at: Date.now() }}));
        }

        // ===== Delta-sync helpers =====
        function getLastSync(key) {
          // keys: 'cards', 'history', 'settings', 'goal_caps'
          const v = localStorage.getItem(`srs_last_${key}_sync`);
          return v ? Number(v) : 0;
        }
        function setLastSync(key, ts) {
          localStorage.setItem(`srs_last_${key}_sync`, String(ts || Date.now()));
        }
        
        async function pullAll() {
          window.srsSync.pulling = true; emitSync();
          window._syncFromCloud = true;
          try {
            const { data: user } = await client.auth.getUser();
            if (!user?.user) return;
            const uid = user.user.id;

            // ---------- CARDS (delta by updated_at) ----------
            // Only changed since last sync; explicit columns only
            // On first install, last=0 → ISO 1970, so you'll get a one-time "full" pull.
            {
              const last = getLastSync('cards');
              const lastIso = new Date(last || 0).toISOString();
              const pageSize = 1000;
              let from = 0, rows = [];
              let ok = true;
              for (;;) {
                const { data, error } = await client
                  .from('cards')
                  .select('id, user_id, ref, text, pack, srs_slow_bucket, srs_slow_next_due, srs_slow_updated_at, srs_fast_bucket, srs_fast_next_due, srs_fast_updated_at, order_in_pack, created_at, updated_at, deleted_at')
                  .eq('user_id', uid)
                  .gt('updated_at', lastIso) // strict 'gt' avoids re-pulling identical timestamps
                  .order('updated_at', { ascending: true })
                  .range(from, from + pageSize - 1);
                if (error) { console.error('cards delta pull error:', error); ok = false; break; }
                rows = rows.concat(data || []);
                if (!data || data.length < pageSize) break;
                from += pageSize;
              }

              if (rows.length) {
                // Map server rows to your app card shape
                const pulled = rows.map(r => ({
                  id: r.id,
                  ref: r.ref,
                  text: r.text,
                  pack: r.pack,
                  srs: {
                    slow: {
                      bucket: r.srs_slow_bucket || '0D',
                      nextDue: Number(r.srs_slow_next_due || 0),
                      updatedAt: r.srs_slow_updated_at ? new Date(r.srs_slow_updated_at).getTime() : 0,
                      ease: 2.5, reps: 0, lapses: 0, intervalDays: 0, leech: false,
                    },
                    fast: {
                      bucket: r.srs_fast_bucket || (r.srs_slow_bucket || '0D'),
                      nextDue: Number(r.srs_fast_next_due || r.srs_slow_next_due || 0),
                      updatedAt: r.srs_fast_updated_at
                        ? new Date(r.srs_fast_updated_at).getTime()
                        : (r.srs_slow_updated_at ? new Date(r.srs_slow_updated_at).getTime() : 0),
                      ease: 2.5, reps: 0, lapses: 0, intervalDays: 0, leech: false,
                    },
                  },
                  order: r.order_in_pack || undefined,
                  createdAt: r.created_at ? new Date(r.created_at).getTime() : 0,
                  updatedAt: r.updated_at ? new Date(r.updated_at).getTime() : 0,
                  deletedAt: r.deleted_at ? new Date(r.deleted_at).getTime() : null,
                }));

                // Merge by id into local; drop if deleted
                const local = getState().cards || [];
                const byId = new Map(local.map(c => [c.id, c]));
                for (const r of pulled) {
                  if (r.deletedAt) {
                    byId.delete(r.id);
                  } else {
                    const cur = byId.get(r.id);
                    if (!cur || (r.updatedAt >= (cur.updatedAt || 0))) {
                      byId.set(r.id, r);
                    }
                  }
                }
                const merged = Array.from(byId.values());
                setCardsLocal(merged);
              }
              if (ok) {
                if (rows.length) {
                  const maxUpdated = Math.max(
                    ...rows.map(r => r.updated_at ? new Date(r.updated_at).getTime() : 0)
                  );
                  if (Number.isFinite(maxUpdated) && maxUpdated > 0) {
                    setLastSync('cards', maxUpdated);
                  } else {
                    setLastSync('cards', Date.now());
                  }
                } else {
                  setLastSync('cards', Date.now());
                }
              }
            }

            // ---------- SETTINGS (delta by updated_at; explicit columns) ----------
            {
              const last = getLastSync('settings');
              const lastIso = new Date(last || 0).toISOString();

              const { data: rows, error } = await client
                .from('settings')
                .select('session_target, show_first_n_words, shuffle, daily_cap_slow, daily_cap_fast, jitter_pct, schema_version, mode, updated_at')
                .eq('user_id', uid)
                .gt('updated_at', lastIso)                // strict gt for cursoring
                .order('updated_at', { ascending: false }) // newest first
                .limit(1);

              const s = rows?.[0];
              if (!error && s) {
                setSettingsLocal({
                  sessionTarget: s.session_target ?? 50,
                  mode: (s.mode === 'full' ? 'review' : (s.mode ?? 'recognition')),
                  showFirstNWords: s.show_first_n_words ?? 6,
                  shuffle: s.shuffle ?? true,
                  dailyCapSlow: s.daily_cap_slow ?? 60,
                  dailyCapFast: s.daily_cap_fast ?? 200,
                  jitterPct: s.jitter_pct ?? 0.1,
                  schemaVersion: s.schema_version ?? 1,
                });
                const t = s.updated_at ? new Date(s.updated_at).getTime() : Date.now();
                setLastSync('settings', t);
              }
              // If no newer row, leave settings + lastSync unchanged.
            }

            // ---------- HISTORY (append since last ts; explicit columns) ----------
            {
              // Start from last seen ms; default to 30d window on first run
              const lastTs = getLastSync('history');
              let cursorIso =
                lastTs > 0
                  ? new Date(lastTs).toISOString()
                  : new Date(Date.now() - 30*24*60*60*1000).toISOString();

              let all = [];
              let ok = true;

              for (;;) {
                const { data, error } = await client
                  .from('history')
                  .select('id, card_id, pack, ref, mode, from_bucket, to_bucket, ts')
                  .eq('user_id', uid)
                  .gt('ts', cursorIso)                 // strict 'gt' for cursoring
                  .order('ts', { ascending: true })
                  .limit(1000);
                if (error) { console.error('history delta pull error:', error); ok = false; break; }
                if (!data || data.length === 0) break;

                all = all.concat(data);
                // advance cursor to the last ts we saw
                cursorIso = data[data.length - 1].ts;
                if (data.length < 1000) break;        // finished
              }

              if (all.length) {
                const pulled = all.map(r => ({
                  id: r.id,
                  cardId: r.card_id,
                  pack: r.pack,
                  ref: r.ref,
                  mode: r.mode,
                  fromBucket: r.from_bucket,
                  toBucket: r.to_bucket,
                  ts: new Date(r.ts).getTime(),
                }));

                // merge newest-by-id, keep last 30d, cap 3000
                const localHist = Array.isArray(getState().history) ? getState().history : [];
                const map = new Map(localHist.map(x => [x.id, x]));
                for (const r of pulled) {
                  const cur = map.get(r.id);
                  if (!cur || r.ts > (cur.ts || 0)) map.set(r.id, r);
                }
                const merged = Array.from(map.values())
                  .filter(x => x.ts >= Date.now() - 30*24*60*60*1000)
                  .sort((a,b) => b.ts - a.ts)
                  .slice(0, 3000);

                setHistoryLocal(merged);

                const maxTs = Math.max(...pulled.map(p => p.ts));
                if (Number.isFinite(maxTs) && ok) setLastSync('history', maxTs);
              }
            }

            // ---------- GOAL CAPS (delta by updated_at; explicit columns) ----------
            {
              const last = getLastSync('goal_caps');
              const lastIso = new Date(last || 0).toISOString();
              const { data: gcRows, error } = await client
                .from('goal_caps')
                .select('day, cap_slow, cap_fast, updated_at')
                .eq('user_id', uid)
                .gt('updated_at', lastIso) // strict gt for cursoring
                .order('updated_at', { ascending: true })
                .limit(2000);

              if (!error && gcRows?.length) {
                const localCap = getState().capLog || {};
                const mergedCap = { ...localCap };
                for (const r of gcRows) {
                  const dayKey = new Date(r.day).toISOString().slice(0,10);
                  mergedCap[dayKey] = { slow: r.cap_slow|0, fast: r.cap_fast|0 };
                }
                setCapLogLocal(mergedCap);
                const maxUpdated = Math.max(
                  ...gcRows.map(r => r.updated_at ? new Date(r.updated_at).getTime() : 0)
                );
                setLastSync('goal_caps', Number.isFinite(maxUpdated) && maxUpdated > 0 ? maxUpdated : Date.now());
              }
            }

            // Single “pull complete” signal
            window.dispatchEvent(new CustomEvent('srs:pulled', { detail: { entity: 'all', at: Date.now() }}));

          } catch (err) {
            console.error('pullAll (delta) failed:', err);
          } finally {
            setTimeout(() => { window._syncFromCloud = false; }, 150);
            window.srsSync.pulling = false;
            window.srsSync.lastPullAt = Date.now();
            emitSync();
          }
        }

        // expose a manual pull as well
        window.pullSRS = pullAll;

        let _opsSincePush = 0;
        window.schedulePush = () => {
          _opsSincePush += 1;
          if (_opsSincePush >= 25) { _opsSincePush = 0; window.pushSRS?.(); }
        };

        // Try to flush before tab closes or app backgrounds (mobile)
        function flushNow() {
          if (window._pushing) return;
          // Only push if something is dirty
          const d = window._dirty || {};
          if (!d.cards && !d.settings && !d.history && !d.capLog) return;
          // Best-effort: fire and forget
          window.pushSRS?.();
        }
        window.addEventListener('visibilitychange', () => {
          if (document.visibilityState === 'hidden') flushNow();
        });
        window.addEventListener('pagehide', flushNow);

        // Expose push function (guarded)
        window.pushSRS = async function pushAll() {
          let hadError = false;
          // Mark pushing
          window.srsSync.pushing = true; emitSync();
          window._pushing = true;

          // helper: batch an array into chunks
          const chunk = (arr, size) => {
            const out = [];
            for (let i = 0; i < arr.length; i += size) out.push(arr.slice(i, i + size));
            return out;
          };

          // helper: stringify a supabase error safely
          const showErr = (err, ctx = "") => {
            console.error("Push error", ctx, err);
            const msg = (err && (err.message || err.error_description || err.hint)) || String(err);
            alert(`${ctx ? ctx + ": " : ""}${msg}`.slice(0, 500));
          };

          try {
            const client = window.supabaseClient;
            if (!client) { alert("Sign in first."); return; }

            const { data: user } = await client.auth.getUser();
            if (!user?.user) { alert("Sign in first."); return; }
            const uid = user.user.id;

            const { cards, settings, history } = getState();
            const nowIso = new Date().toISOString();

            // --------- CARDS (BATCHED UPSERT) ----------
            if (window._dirty.cards && cards?.length) {
              const rows = cards.map(c => {
                const slow = c?.srs?.slow || {};
                const fast = c?.srs?.fast || {};
                const content_hash = (c.contentHash || (function(s){
                  let h=2166136261>>>0;
                  for(let i=0;i<s.length;i++){h^=s.charCodeAt(i);h=Math.imul(h,16777619)}
                  return (h>>>0).toString(36)
                })(`${c.ref}|${c.text}`));

                return {
                  id: c.id || crypto.randomUUID(),
                  user_id: uid,
                  ref: c.ref, text: c.text, pack: c.pack,
                  content_hash,

                  srs_slow_bucket: slow.bucket || '0D',
                  srs_slow_next_due: Number(slow.nextDue || 0),
                  srs_slow_updated_at: slow.updatedAt ? new Date(slow.updatedAt).toISOString() : nowIso,

                  srs_fast_bucket: fast.bucket || (slow.bucket || '0D'),
                  srs_fast_next_due: Number(fast.nextDue || slow.nextDue || 0),
                  srs_fast_updated_at: fast.updatedAt
                      ? new Date(fast.updatedAt).toISOString()
                      : (slow.updatedAt ? new Date(slow.updatedAt).toISOString() : nowIso),

                  order_in_pack: c.order || null,

                  created_at: c.createdAt ? new Date(c.createdAt).toISOString() : nowIso,
                  updated_at: c.updatedAt ? new Date(c.updatedAt).toISOString() : nowIso,
                  deleted_at: c.deletedAt ? new Date(c.deletedAt).toISOString() : null,
                };
              });

              // Batch at 200 rows to avoid payload/timeouts
              for (const part of chunk(rows, 200)) {
                const { error } = await client.from('cards').upsert(part, { onConflict: 'id' });
                if (error) {
                  // If you ever see a unique violation on (user_id, content_hash), it means
                  // you have two different card IDs with identical ref|text. Merge or delete duplicates.
                  hadError = true;
                  showErr(error, "Cards push failed");
                  break;
                }
              }
            }

            // --------- SETTINGS (single-row upsert) ----------
            if (window._dirty.settings) {
              const { error } = await client.from('settings').upsert({
                user_id: uid,
                session_target: settings?.sessionTarget ?? 50,
                show_first_n_words: settings?.showFirstNWords ?? 6,
                shuffle: settings?.shuffle ?? true,
                daily_cap_slow: settings?.dailyCapSlow ?? 60,
                daily_cap_fast: settings?.dailyCapFast ?? 200,
                jitter_pct: settings?.jitterPct ?? 0.1,
                schema_version: settings?.schemaVersion ?? 1,
                updated_at: nowIso,
              });
              if (error) { hadError = true; showErr(error, "Settings push failed"); }
            }

            // --------- HISTORY (BATCHED UPSERT) ----------
            const recent = Array.isArray(history) ? history.slice(-2000) : [];
            if (window._dirty.history && recent.length) {
              // Build a set of valid card ids (after we upserted cards above)
              const validCardIds = new Set((cards || []).map(c => c.id));

              const rows = recent.map(h => ({
                id: h.id || crypto.randomUUID(),
                user_id: uid,
                // If the referenced card no longer exists (id changed or card deleted), store NULL
                card_id: validCardIds.has(h.cardId) ? h.cardId : null,
                pack: h.pack,
                ref: h.ref,
                mode: h.mode, // 'slow' | 'fast'
                from_bucket: h.fromBucket,
                to_bucket: h.toBucket,
                ts: h.ts ? new Date(h.ts).toISOString() : nowIso,
              }));

              for (const part of chunk(rows, 500)) {
                const { error } = await client.from('history').upsert(part, { onConflict: 'id' });
                if (error) { hadError = true; showErr(error, "History push failed"); break; }
              }
            }

            // --------- GOAL CAPS (BATCHED UPSERT) ----------
            if (window._dirty.capLog) {
              const { capLog } = getState();
              const entries = Object.entries(capLog || {});
              if (entries.length) {
                // convert to rows: PK is (user_id, day)
                const rows = entries.map(([dayKey, caps]) => ({
                  user_id: uid,
                  day: dayKey, // 'YYYY-MM-DD' is fine for a Postgres DATE
                  cap_slow: Number(caps?.slow || 0),
                  cap_fast: Number(caps?.fast || 0),
                  updated_at: nowIso,
                }));

                // batch to be friendly with payload/RT limits
                for (let i = 0; i < rows.length; i += 500) {
                  const chunkRows = rows.slice(i, i + 500);
                  const { error } = await client
                    .from('goal_caps')
                    .upsert(chunkRows, { onConflict: 'user_id,day' });
                  if (error) { hadError = true; showErr(error, "Goal caps push failed"); break; }
                }
              }
            }

          } catch (err) {
            hadError = true;
            showErr(err, "Push failed");
          } finally {
            window._pushing = false;
            window.srsSync.pushing = false;
            // If we didn't error, clear dirty flags now
            if (!hadError) {
              window._dirty = { cards:false, settings:false, history:false, capLog:false };
              _opsSincePush = 0; // reset the burst counter after a successful push
            }
            window.srsSync.lastPushAt = Date.now();
            emitSync();
          }
        };

        async function startRealtime(uid) {
          // Free-tier: no realtime to avoid quota burn.
          return;
        }

        async function stopRealtime() { /* free-tier: no realtime */ }
      }

      function boot() {
        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', () => ready(start));
        } else {
          ready(start);
        }
      }
      boot();
    })();
    </script>
   
  </body>
</html>
<!-- bump -->