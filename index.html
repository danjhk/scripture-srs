<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Scripture SRS</title>
    <!-- Tailwind (for the classes you already use) -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React + ReactDOM + Babel (lets us run your JSX in-browser) -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Supabase UMD -->
    <script src="https://unpkg.com/@supabase/supabase-js@2.45.4/dist/umd/supabase.js"></script>

    <!-- Put your Supabase keys here later (Phase 2). For now, leave empty. -->
    <script>
      window.SUPABASE_URL = "https://wfqbfapvwrulfzblskws.supabase.co";   // e.g., "https://xxxx.supabase.co"
      window.SUPABASE_ANON = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6IndmcWJmYXB2d3J1bGZ6Ymxza3dzIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTg0NTkxMTUsImV4cCI6MjA3NDAzNTExNX0.lzLU2X3sY6seixhUyJqQu4jaw84CmtQnsLl328fPB9o";  // e.g., "eyJhbGciOiJIUzI1NiIsInR5cCI6Ikp..."
    </script>

    <style>
      body { background: #f8fafc; }
    </style>
  </head>
  <body>
    <div id="root"></div>

    <!-- Your app code -->
    <script type="text/babel" data-type="module" src="./app.jsx"></script>

    <script>
    (function initAuthBar() {
      // Render the bar immediately so something is visible
      const bar = document.createElement('div');
      bar.style.position='fixed'; bar.style.top='8px'; bar.style.right='8px'; bar.style.zIndex='100000';
      bar.innerHTML = `
        <button id="srs-signin" class="px-3 py-2 rounded-xl bg-indigo-600 text-white">Sign in</button>
        <button id="srs-signout" class="px-3 py-2 rounded-xl bg-gray-200" style="display:none">Sign out</button>
      `;
      document.body.appendChild(bar);

      const signinBtn  = document.getElementById('srs-signin');
      const signoutBtn = document.getElementById('srs-signout');

      // Hide both buttons until we know the auth state
      signinBtn.style.display = 'none';
      signoutBtn.style.display = 'none';

      // Disable until Supabase is loaded
      signinBtn.disabled = true;
      signinBtn.textContent = 'Loading...';

      function ready(cb) {
        if (window.supabase) return cb();
        const s = document.querySelector('script[src*="supabase-js"]');
        if (s) s.addEventListener('load', () => cb(), { once: true });
        const t = setInterval(() => {
          if (window.supabase) { clearInterval(t); cb(); }
        }, 50);
      }

      // --- NEW: make start async and only clean hash AFTER session is set
      async function start() {
        const client = window.supabase.createClient(
          window.SUPABASE_URL,
          window.SUPABASE_ANON,
          { auth: { persistSession: true, detectSessionInUrl: true } }
        );
        window.supabaseClient = client;
        let didInitialPull = false;
        // --- Sync status (global) ---
        window.srsSync = { pushing:false, pulling:false, lastPullAt:null, lastPushAt:null };
        const emitSync = () => window.dispatchEvent(new CustomEvent('srs-sync'));

        let poller = null;
        let channel = null;
        window._pushing = false;        // guard: we're currently pushing
        window._syncFromCloud = false;  // guard: we're applying pull → don't auto-push

        const debounce = (fn, ms = 2000) => {
          let t; return (...args) => { clearTimeout(t); t = setTimeout(() => fn(...args), ms); };
        };

        const cleanupHash = () => {
          if (location.hash && location.hash.includes('access_token')) {
            history.replaceState({}, '', location.pathname + location.search);
          }
        };

        async function refreshButtons() {
          const { data } = await client.auth.getUser();
          const signedIn = !!data.user;
          signinBtn.style.display  = signedIn ? 'none' : '';
          signoutBtn.style.display = signedIn ? '' : 'none';

          if (signedIn && !didInitialPull) {
            didInitialPull = true;
            const uid = data.user.id;
            await pullAll();
            await startRealtime(uid);
          }
          if (!signedIn) { await stopRealtime(); }
        }

        signinBtn.disabled = false;
        signinBtn.textContent = 'Sign in';

        signinBtn.onclick = async () => {
          const email = prompt("Enter your email for a sign-in link:");
          if (!email) return;
          const redirectTo = `${location.origin}${location.pathname}`; // exact page (no hash/query)
          const { error } = await client.auth.signInWithOtp({
            email,
            options: { emailRedirectTo: redirectTo }
          });
          if (error) alert(error.message);
          else alert("Check your email and click the sign-in link.");
        };

        signoutBtn.onclick = async () => {
          await client.auth.signOut();
          await stopRealtime();
          refreshButtons();
        };

        // --- NEW: let Supabase parse URL first, then tidy URL if signed in
        const { data: { session } } = await client.auth.getSession();
        if (session?.user) cleanupHash();
        await refreshButtons();

        client.auth.onAuthStateChange((event, session) => {
          console.log('Auth event:', event, session?.user?.email || null);
          if (event === 'SIGNED_IN' && session?.user) cleanupHash();
          refreshButtons(); // safe; won't loop-pull now
        });

        // ---- your existing helpers (unchanged) ----
        function getState() {
          try {
            const s = JSON.parse(localStorage.getItem("scripture_srs_v1")) || { cards:[], settings:{} };
            if (!s.capLog) s.capLog = {};  // ← NEW: ensure present
            return s;
          } catch {
            return { cards:[], settings:{}, capLog:{} };
          }
        }
        function setCardsLocal(cards) {
          const st = getState(); st.cards = cards;
          localStorage.setItem("scripture_srs_v1", JSON.stringify(st));
          // Let the app know cloud data landed:
          window.dispatchEvent(new CustomEvent('srs:pulled', { detail: { entity: 'cards', at: Date.now() }}));
        }
        function setSettingsLocal(settings) {
          const st = getState(); st.settings = settings;
          localStorage.setItem("scripture_srs_v1", JSON.stringify(st));
          window.dispatchEvent(new CustomEvent('srs:pulled', { detail: { entity: 'settings', at: Date.now() }}));
        }

        function setHistoryLocal(history) {
          const st = getState(); st.history = history;
          localStorage.setItem("scripture_srs_v1", JSON.stringify(st));
          window.dispatchEvent(new CustomEvent('srs:pulled', { detail: { entity: 'history', at: Date.now() }}));
        }

        function setCapLogLocal(capLog) {
          const st = getState(); st.capLog = capLog;
          localStorage.setItem("scripture_srs_v1", JSON.stringify(st));
          window.dispatchEvent(new CustomEvent('srs:pulled', { detail: { entity: 'capLog', at: Date.now() }}));
        }

        async function pullAll() {
          // Mark pulling
          window.srsSync.pulling = true; emitSync();
          window._syncFromCloud = true;
          try {
            const { data: user } = await client.auth.getUser();
            if (!user?.user) return;
            const uid = user.user.id;

            // --- CARDS ---
            const { data: rows, error: e1 } = await client
              .from('cards')
              .select('*')
              .eq('user_id', uid);

            if (e1) { console.error(e1); return; }

            const pulledCards = (rows || []).map(r => ({
            id: r.id,
            ref: r.ref,
            text: r.text,
            pack: r.pack,
            srs: {
              slow: {
                bucket: r.srs_slow_bucket || '0D',
                nextDue: Number(r.srs_slow_next_due || 0),
                updatedAt: r.srs_slow_updated_at ? new Date(r.srs_slow_updated_at).getTime() : 0,
                ease: 2.5, reps: 0, lapses: 0, intervalDays: 0, leech: false,
              },
              fast: {
                bucket: r.srs_fast_bucket || (r.srs_slow_bucket || '0D'),
                nextDue: Number(r.srs_fast_next_due || r.srs_slow_next_due || 0),
                updatedAt: r.srs_fast_updated_at ? new Date(r.srs_fast_updated_at).getTime()
                                                  : (r.srs_slow_updated_at ? new Date(r.srs_slow_updated_at).getTime() : 0),
                ease: 2.5, reps: 0, lapses: 0, intervalDays: 0, leech: false,
              },
            },
            order: r.order_in_pack || undefined,
            createdAt: new Date(r.created_at).getTime(),
            updatedAt: new Date(r.updated_at).getTime(),
            deletedAt: r.deleted_at ? new Date(r.deleted_at).getTime() : null,
          }));

          // Merge with local, but treat "missing on server" as deleted.
          // Keep whichever copy (local vs remote) is fresher *only for ids the server still has*.
          const local = getState().cards || [];
          const localById = new Map(local.map(c => [c.id, c]));

          const merged = [];
          for (const r of pulledCards) {
            const l = localById.get(r.id);
            // If no local or remote is fresher/equal, use remote; otherwise keep local
            merged.push(!l || r.updatedAt >= (l.updatedAt || 0) ? r : l);
          }
          // Anything in local that's not on the server is considered deleted → drop it.
          setCardsLocal(merged.filter(c => !c.deletedAt));

          // --- SETTINGS ---
          const { data: s, error: e2 } = await client
            .from('settings')
            .select('*')
            .eq('user_id', uid)
            .maybeSingle();

            if (!e2 && s) {
              setSettingsLocal({
                sessionTarget: s.session_target ?? 50,
                mode: s.mode ?? 'recognition',
                showFirstNWords: s.show_first_n_words ?? 6,
                shuffle: s.shuffle ?? true,
                dailyCapSlow: s.daily_cap_slow ?? 60,
                dailyCapFast: s.daily_cap_fast ?? 200,
                jitterPct: s.jitter_pct ?? 0.1,
                schemaVersion: s.schema_version ?? 1,
              });
            }

            // --- HISTORY (last 30 days, capped) ---
            const sinceIso = new Date(Date.now() - 30*24*60*60*1000).toISOString();
            const { data: hrows, error: eh } = await client
              .from('history')
              .select('*')
              .eq('user_id', uid)
              .gte('ts', sinceIso)
              .order('ts', { ascending: false })
              .limit(3000);

            if (!eh && hrows) {
              const pulled = (hrows || []).map(r => ({
                id: r.id,
                cardId: r.card_id,
                pack: r.pack,
                ref: r.ref,
                mode: r.mode,            // 'fast' | 'slow'
                fromBucket: r.from_bucket,
                toBucket: r.to_bucket,
                ts: new Date(r.ts).getTime(),
              }));

              const localHist = Array.isArray(getState().history) ? getState().history : [];
              const map = new Map(localHist.map(x => [x.id, x]));
              for (const r of pulled) {
                const l = map.get(r.id);
                if (!l || r.ts > (l.ts || 0)) map.set(r.id, r);
              }
              const merged = Array.from(map.values())
                .filter(x => x.ts >= Date.now() - 30*24*60*60*1000) // keep 30d window
                .sort((a,b) => b.ts - a.ts)
                .slice(0, 3000);

              setHistoryLocal(merged);
            }

            // --- GOAL CAPS (all rows, or cap to recent) ---
            const { data: gcRows, error: egc } = await client
              .from('goal_caps')
              .select('*')
              .eq('user_id', uid)
              .order('day', { ascending: false })
              .limit(2000); // plenty for multiple years

            if (!egc && gcRows) {
              // Merge: server overrides the same day keys; keep any local-only days
              const localCap = getState().capLog || {};
              const mergedCap = { ...localCap };
              for (const r of gcRows) {
                const dayKey = new Date(r.day).toISOString().slice(0,10); // YYYY-MM-DD
                mergedCap[dayKey] = { slow: r.cap_slow|0, fast: r.cap_fast|0 };
              }
              setCapLogLocal(mergedCap);
            }

            // Single “pull complete” signal
            window.dispatchEvent(new CustomEvent('srs:pulled', { detail: { entity: 'all', at: Date.now() }}));

          } catch (err) {
            console.error('pullAll failed:', err);
          } finally {
            // Release the guard after a tick so app can apply state without triggering push
            setTimeout(() => { window._syncFromCloud = false; }, 150);
            // Done pulling
            window.srsSync.pulling = false;
            window.srsSync.lastPullAt = Date.now();
            emitSync();
          }
        }

        // expose a manual pull as well
        window.pullSRS = pullAll;

        // Expose a debounced scheduler for auto-push (used by app.jsx)
        window.schedulePush = debounce(() => window.pushSRS?.(), 1500);

        // Expose push function (guarded)
        window.pushSRS = async function pushAll() {
          // Mark pushing
          window.srsSync.pushing = true; emitSync();
          window._pushing = true;
          try {
            const { data: user } = await client.auth.getUser();
            if (!user?.user) { alert("Sign in first."); return; }
            const uid = user.user.id;

            const { cards, settings, history } = getState();
            const nowIso = new Date().toISOString();

            // --- CARDS UPSERT ---
            if (cards?.length) {
              const rows = cards.map(c => {
              const slow = c?.srs?.slow || {};
              const fast = c?.srs?.fast || {};
              const content_hash = (c.contentHash || (function(s){
                let h=2166136261>>>0;
                for(let i=0;i<s.length;i++){h^=s.charCodeAt(i);h=Math.imul(h,16777619)}
                return (h>>>0).toString(36)
              })(`${c.ref}|${c.text}`));

              return {
                id: c.id || crypto.randomUUID(),
                user_id: uid,
                ref: c.ref, text: c.text, pack: c.pack,
                content_hash,

                // dual schedule fields
                srs_slow_bucket: slow.bucket || '0D',
                srs_slow_next_due: Number(slow.nextDue || 0),
                srs_slow_updated_at: slow.updatedAt ? new Date(slow.updatedAt).toISOString() : nowIso,

                srs_fast_bucket: fast.bucket || (slow.bucket || '0D'),
                srs_fast_next_due: Number(fast.nextDue || slow.nextDue || 0),
                srs_fast_updated_at: fast.updatedAt
                    ? new Date(fast.updatedAt).toISOString()
                    : (slow.updatedAt ? new Date(slow.updatedAt).toISOString() : nowIso),

                order_in_pack: c.order || null,

                created_at: c.createdAt ? new Date(c.createdAt).toISOString() : nowIso,
                updated_at: c.updatedAt ? new Date(c.updatedAt).toISOString() : nowIso,
                deleted_at: c.deletedAt ? new Date(c.deletedAt).toISOString() : null,
              };
              });

              const { error } = await client.from('cards').upsert(rows, { onConflict: 'id' });
              if (error) { console.error(error); alert("Cards push failed."); return; }
            }

            // --- SETTINGS UPSERT ---
            await client.from('settings').upsert({
              user_id: uid,
              session_target: settings?.sessionTarget ?? 50,
              mode: settings?.mode ?? 'recognition',
              show_first_n_words: settings?.showFirstNWords ?? 6,
              shuffle: settings?.shuffle ?? true,
              daily_cap_slow: settings?.dailyCapSlow ?? 60,
              daily_cap_fast: settings?.dailyCapFast ?? 200,
              jitter_pct: settings?.jitterPct ?? 0.1,
              schema_version: settings?.schemaVersion ?? 1,
              updated_at: nowIso,
            });

            // --- HISTORY APPEND (optional but recommended) ---
            const recent = Array.isArray(history) ? history.slice(-500) : [];
            if (recent.length) {
              const rows = recent.map(h => ({
                id: h.id || crypto.randomUUID(),
                user_id: uid,
                card_id: h.cardId,
                pack: h.pack,
                ref: h.ref,
                mode: h.mode, // 'slow' | 'fast'
                from_bucket: h.fromBucket,
                to_bucket: h.toBucket,
                ts: h.ts ? new Date(h.ts).toISOString() : nowIso,
              }));
              const { error } = await client.from('history').upsert(rows, { onConflict: 'id' });
              if (error) { console.error(error); /* do not block the rest */ }
            }

            // --- GOAL CAPS UPSERT ---
            const capLog = (getState().capLog) || {};
            const capEntries = Object.entries(capLog);
            if (capEntries.length) {
              const rows = capEntries.map(([dayKey, v]) => ({
                user_id: uid,
                day: dayKey,              // YYYY-MM-DD
                cap_slow: Number(v?.slow ?? 0),
                cap_fast: Number(v?.fast ?? 0),
                updated_at: nowIso,
              }));
              const { error: egc } = await client
                .from('goal_caps')
                .upsert(rows, { onConflict: 'user_id,day' });
              if (egc) { console.error('goal_caps push failed', egc); /* non-fatal */ }
            }

          } catch (err) {
            console.error('pushAll failed:', err);
          } finally {
            window._pushing = false;
            // Done pushing
            window.srsSync.pushing = false;
            window.srsSync.lastPushAt = Date.now();
            emitSync();
          }
        };

        const pushBtn = document.createElement('button');
        pushBtn.textContent = 'Push to Cloud';
        pushBtn.className = 'fixed bottom-4 right-4 px-4 py-2 rounded-xl bg-emerald-600 text-white shadow';
        pushBtn.onclick = () => window.pushSRS();
        document.body.appendChild(pushBtn);

        async function startRealtime(uid) {
          const schedulePull = (function () {
            let t = null;
            return () => {
              if (window._pushing) return;
              clearTimeout(t);
              t = setTimeout(() => pullAll(), 250); // batch events
            };
          })();

          // Unsubscribe existing
          if (channel) { try { await client.removeChannel(channel); } catch {} channel = null; }
          // Subscribe to user-scoped changes
          channel = client.channel('realtime:cards_settings_history')
            .on('postgres_changes',
              { event: '*', schema: 'public', table: 'cards', filter: `user_id=eq.${uid}` },
              () => schedulePull())
            .on('postgres_changes',
              { event: '*', schema: 'public', table: 'settings', filter: `user_id=eq.${uid}` },
              () => schedulePull())
            .on('postgres_changes',
              { event: '*', schema: 'public', table: 'history', filter: `user_id=eq.${uid}` },
              () => schedulePull())
            .on('postgres_changes',
              { event: '*', schema: 'public', table: 'goal_caps', filter: `user_id=eq.${uid}` },
              () => schedulePull())
            .subscribe((status) => { console.log('Realtime status:', status); });


          // Poll as a safety net (missed events / offline resume)
          if (poller) clearInterval(poller);
          poller = setInterval(() => { if (!window._pushing) pullAll(); }, 60000);
        }

        async function stopRealtime() {
          if (poller) { clearInterval(poller); poller = null; }
          if (channel) { try { await client.removeChannel(channel); } catch {} channel = null; }
        }
      }

      function boot() {
        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', () => ready(start));
        } else {
          ready(start);
        }
      }
      boot();
    })();
    </script>
   
  </body>
</html>
<!-- bump -->